<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hoodie or Nah</title>
  <meta name="description" content="Settle the hoodie debate. Hoodie judgment, delivered." />
  <meta name="theme-color" content="#0b0b0f" />

  <!-- Favicons / App Icons -->
  <link rel="icon" href="/favicon.ico" sizes="any" />
  <link rel="icon" type="image/png" href="/favicon-32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/favicon-16.png" sizes="16x16" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180" />
  <link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192" />
  <link rel="icon" type="image/png" href="/android-chrome-512x512.png" sizes="512x512" />

  <!-- Open Graph / Social Sharing -->
  <meta property="og:title" content="Hoodie or Nah?" />
  <meta property="og:description" content="Settle the hoodie debate in one click based on the weather." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://hoodieornah.com" />
  <meta property="og:image" content="https://hoodieornah.com/og.png" />

  <!-- Twitter / X -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Hoodie or Nah?" />
  <meta name="twitter:description" content="Settle the hoodie debate in one click based on the weather." />
  <meta name="twitter:image" content="https://hoodieornah.com/og.png" />

  <style>
    :root{
      --bg:#0b0b0f;
      --panel: rgba(255,255,255,.04);
      --panel2: rgba(255,255,255,.03);
      --stroke: rgba(255,255,255,.10);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --muted2: rgba(255,255,255,.58);
      --accent: rgba(255,255,255,.92);
      --shadow: 0 18px 45px rgba(0,0,0,.55);
      --shadow2: 0 10px 25px rgba(0,0,0,.45);
      --radius: 22px;
      --radius2: 16px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:
        radial-gradient(1200px 520px at 20% 10%, rgba(255,255,255,.07), transparent 60%),
        radial-gradient(900px 500px at 80% 20%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(900px 520px at 40% 90%, rgba(255,255,255,.05), transparent 65%),
        var(--bg);
      color: var(--text);
      overflow-x:hidden;
    }

    .wrap{
      max-width: 1220px;
      margin: 18px auto 28px;
      padding: 0 18px 26px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 14px;
      padding: 14px 18px;
      border: 1px solid var(--stroke);
      border-radius: 999px;
      background: linear-gradient(to bottom, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: var(--shadow2);
      position: sticky;
      top: 10px;
      backdrop-filter: blur(14px);
      z-index: 50;
    }

    .brand{
      display:flex;
      align-items:center;
      gap: 12px;
      min-width: 260px;
      cursor:pointer;
      user-select:none;
    }

    .brand .mark{
      width: 38px;
      height: 38px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(14px 14px at 30% 30%, rgba(255,255,255,.14), transparent 60%),
        rgba(255,255,255,.04);
      display:grid;
      place-items:center;
      box-shadow: 0 10px 25px rgba(0,0,0,.45);
      transition: transform .18s ease, box-shadow .18s ease, filter .18s ease;
    }

    .brand:hover .mark{
      transform: translateY(-1px) scale(1.02);
      filter: drop-shadow(0 0 12px rgba(255,255,255,.10));
    }

    .brand .word{
      display:flex;
      flex-direction:column;
      line-height:1.05;
    }

    .brand .word strong{
      font-size: 18px;
      letter-spacing: .01em;
    }
    .brand .word span{
      font-size: 12px;
      color: var(--muted);
      letter-spacing: .02em;
    }

    .controls{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content:flex-end;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 9px 12px;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      background: rgba(255,255,255,.03);
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      user-select:none;
      white-space: nowrap;
      transition: background .16s ease, border-color .16s ease, transform .16s ease;
    }
    .pill:hover{ background: rgba(255,255,255,.05); border-color: rgba(255,255,255,.18); transform: translateY(-1px); }
    .pill[aria-pressed="true"]{ background: rgba(255,255,255,.07); border-color: rgba(255,255,255,.22); }

    .seg{
      display:flex;
      align-items:center;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      overflow:hidden;
      background: rgba(255,255,255,.03);
    }
    .seg button{
      border:0;
      background:transparent;
      color: var(--muted);
      padding: 8px 12px;
      font-size: 13px;
      cursor:pointer;
      transition: background .16s ease, color .16s ease;
    }
    .seg button:hover{ background: rgba(255,255,255,.05); color: var(--text); }
    .seg button[aria-pressed="true"]{ background: rgba(255,255,255,.08); color: var(--text); }

    .main{
      margin-top: 14px;
      display:grid;
      grid-template-columns: 1.25fr .95fr;
      gap: 14px;
    }

    @media (max-width: 980px){
      .brand{ min-width: unset; }
      .main{ grid-template-columns: 1fr; }
    }

    .card{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      background: linear-gradient(to bottom, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      overflow:hidden;
      position: relative;
    }

    .card::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(420px 220px at 20% 0%, rgba(255,255,255,.07), transparent 60%);
      pointer-events:none;
    }

    .card-inner{ position:relative; padding: 18px; }

    .bigword{
      font-size: 72px;
      font-weight: 900;
      letter-spacing: .02em;
      margin: 6px 0 4px;
      line-height: .9;
    }

    .oneliner{
      color: var(--muted);
      font-size: 15px;
      margin: 0 0 16px;
      max-width: 560px;
    }

    .statrow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .stat{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      background: rgba(0,0,0,.12);
      padding: 12px 12px;
      min-height: 70px;
    }

    .stat small{ display:block; color: var(--muted2); font-size:12px; margin-bottom: 6px; }
    .stat strong{ display:block; font-size: 15px; }
    .stat .sub{ margin-top: 4px; color: var(--muted2); font-size: 12px; }

    .forecast{
      margin-top: 14px;
      display:flex;
      gap: 10px;
      overflow-x:auto;
      padding-bottom: 6px;
      scroll-snap-type: x mandatory;
    }
    .forecast::-webkit-scrollbar{ height: 10px; }
    .forecast::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.10); border-radius: 10px; }
    .forecast-item{
      scroll-snap-align: start;
      min-width: 128px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      background: rgba(0,0,0,.10);
      padding: 12px 12px;
      cursor:pointer;
      transition: transform .16s ease, background .16s ease, border-color .16s ease;
      user-select:none;
      outline: none;
    }
    .forecast-item:hover{
      transform: translateY(-2px);
      background: rgba(255,255,255,.04);
      border-color: rgba(255,255,255,.16);
    }
    .forecast-item:focus-visible{ box-shadow: 0 0 0 3px rgba(255,255,255,.12); }
    .forecast-item.selected{ border-color: rgba(255,255,255,.24); background: rgba(255,255,255,.05); }

    .forecast-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 8px;
    }
    .forecast-top b{ font-size: 13px; }
    .forecast-top svg{ width: 20px; height: 20px; opacity: .95; }
    .forecast-mid{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .forecast-mid strong{ color: var(--text); font-size: 14px; display:block; margin-top: 4px; }
    .forecast-line{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted2);
      line-height: 1.25;
      min-height: 34px;
    }

    /* Footer layout tweak: remove awkward dead space and nudge support lower */
    .left-footer{
      margin-top: 16px;
      display:block;
    }
    .cta{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
      margin-top: 12px;
    }
    #supportBtn{ margin-top: 6px; }
    #unitsLine{
      margin-top: 10px;
      color: var(--muted2);
      font-size: 12px;
      text-align:right;
    }

    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
      padding: 10px 14px;
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      color: var(--text);
      font-size: 13px;
      cursor:pointer;
      text-decoration:none;
      transition: transform .16s ease, background .16s ease, border-color .16s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.07); border-color: rgba(255,255,255,.20); }
    .btn.secondary{ background: rgba(0,0,0,.10); }
    .btn.secondary:hover{ background: rgba(255,255,255,.05); }

    .right-card h2{
      margin: 0;
      font-size: 22px;
      letter-spacing: .01em;
    }
    .right-card .subhead{
      margin-top: 6px;
      color: var(--muted);
      font-size: 13px;
    }

    label{ display:block; margin-top: 12px; color: var(--muted2); font-size: 12px; letter-spacing: .02em; }
    select, input{
      width:100%;
      margin-top: 6px;
      padding: 11px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
      font-size: 14px;
      transition: border-color .16s ease, background .16s ease;
    }
    input::placeholder{ color: rgba(255,255,255,.38); }
    input:focus, select:focus{
      border-color: rgba(255,255,255,.24);
      background: rgba(0,0,0,.26);
    }
    select option{
      background: #0b0b0f;
      color: rgba(255,255,255,.92);
    }

    .form-row{
      margin-top: 10px;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .form-row .btn{ flex: 1 1 auto; min-width: 160px; }

    .using{
      margin-top: 14px;
      border-top: 1px solid rgba(255,255,255,.10);
      padding-top: 14px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 10px;
      font-size: 13px;
      color: var(--muted);
      align-items:center;
    }
    .using .k{ color: var(--muted2); }
    .using .v{ color: var(--text); font-weight: 650; display:flex; align-items:center; gap:8px; justify-content:flex-end; }
    .using .v .pin{ opacity:.9; }
    .using .help{ grid-column: 1 / -1; text-align:right; color: var(--muted2); font-size: 12px; }

    .details{
      margin-top: 14px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      background: rgba(0,0,0,.14);
      overflow:hidden;
    }
    .details-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 12px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .details-header b{ font-size: 13px; }
    .details-header button{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: var(--text);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      cursor:pointer;
      transition: background .16s ease, transform .16s ease;
    }
    .details-header button:hover{ background: rgba(255,255,255,.06); transform: translateY(-1px); }

    .details-body{ padding: 12px; }
    .details-title{ font-size:16px; font-weight:800; color:var(--text); }
    .details-meta{ color:var(--muted); font-size:13px; display:flex; align-items:center; gap:8px; }
    .details-meta svg{ width:34px; height:34px; flex:0 0 auto; }
    .sunrow{ width:100%; margin-top:10px; display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .sunbox{ border:1px solid rgba(255,255,255,.10); border-radius:14px; padding:10px 12px; background: rgba(255,255,255,.02); }
    .sunlabel{ display:block; font-size:12px; color:var(--muted); letter-spacing:.02em; }
    .sunvalue{ display:block; margin-top:2px; font-size:14px; font-weight:700; color:var(--text); }

    .site-footer{
      margin-top: 14px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(255,255,255,.03);
      padding: 14px 14px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 14px;
      color: var(--muted2);
      font-size: 12px;
      line-height: 1.3;
      flex-wrap: wrap;
    }
    .site-footer a{ color: rgba(255,255,255,.85); text-decoration:none; border-bottom: 1px solid rgba(255,255,255,.20); }
    .site-footer a:hover{ border-bottom-color: rgba(255,255,255,.40); }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(10,10,14,.88);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      padding: 10px 14px;
      color: rgba(255,255,255,.92);
      box-shadow: var(--shadow2);
      opacity: 0;
      pointer-events:none;
      transition: opacity .20s ease, transform .20s ease;
      z-index: 120;
      font-size: 13px;
      max-width: 92vw;
    }
    .toast.show{ opacity:1; transform: translateX(-50%) translateY(-6px); }

    .spinner{
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,.22);
      border-top-color: rgba(255,255,255,.85);
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }

    .loading-overlay{
      position:absolute;
      inset:0;
      background: radial-gradient(420px 240px at 20% 0%, rgba(255,255,255,.06), transparent 60%),
                  rgba(10,10,14,.40);
      display:none;
      align-items:center;
      justify-content:center;
      backdrop-filter: blur(10px);
      z-index: 40;
    }
    .loading-overlay.show{ display:flex; }

    .loader-mark{
      width: 48px;
      height: 48px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      display:grid;
      place-items:center;
      box-shadow: var(--shadow2);
    }
    .loader-mark svg{ width: 26px; height: 26px; opacity:.9; }

    .modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.60);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 200;
      padding: 18px;
    }
    .modal{
      width: min(720px, 96vw);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      background: rgba(15,15,20,.92);
      box-shadow: var(--shadow);
      padding: 14px;
      color: var(--text);
    }
    .modal header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin-bottom: 10px;
    }
    .modal header b{ font-size: 14px; }
    .modal header button{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      color: var(--text);
      border-radius: 999px;
      padding: 8px 10px;
      cursor:pointer;
    }

    .qmark-anim{
      transform-origin: 50% 50%;
      animation: popQ 0.9s ease 1;
    }
    @keyframes popQ{
      0%{ transform: translateY(0) scale(1); opacity: .85; }
      40%{ transform: translateY(-1px) scale(1.06); opacity: 1; }
      100%{ transform: translateY(0) scale(1); opacity: .92; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand" id="brandHome" title="Back to auto location">
        <div class="mark" aria-hidden="true">
          <img src="/android-chrome-192x192.png" alt="" style="width:26px;height:26px;display:block;" />
        </div>
        <div class="word">
          <strong>Hoodie or Nah</strong>
          <span>Hoodie judgment, delivered.</span>
        </div>
      </div>

      <div class="controls">
        <div class="seg" aria-label="Units">
          <button class="unit-btn" id="unitAuto" aria-pressed="true">Auto</button>
          <button class="unit-btn" id="unitF" aria-pressed="false">¬∞F</button>
          <button class="unit-btn" id="unitC" aria-pressed="false">¬∞C</button>
        </div>
        <div class="pill" id="wherePill" title="Click for details or copy">
          <span class="spinner" id="pillSpinner" style="display:none"></span>
          <span class="pin">üìç</span>
          <span id="pillText">Near you</span>
        </div>
      </div>
    </div>

    <div class="main">
      <!-- Left -->
      <div class="card">
        <div class="loading-overlay" id="loadingOverlay">
          <div class="loader-mark" aria-hidden="true">
            <svg viewBox="0 0 64 64" fill="none">
              <path d="M20 44c-3.5-3-6-7.5-6-13 0-9.4 7.6-17 17-17 9.4 0 17 7.6 17 17 0 5.5-2.5 10-6 13" stroke="currentColor" stroke-width="3" stroke-linecap="round" opacity=".9"/>
              <path class="qmark-anim" d="M31.7 40.5v-2.2c0-2.9 4.9-3 4.9-7.3 0-2.7-2.2-4.7-5.4-4.7-2.6 0-4.9 1.2-6.1 3.1" stroke="currentColor" stroke-width="3" stroke-linecap="round" opacity=".95"/>
              <circle cx="32" cy="47.8" r="1.7" fill="currentColor" opacity=".95"/>
            </svg>
          </div>
        </div>

        <div class="card-inner">
          <div class="bigword" id="bigWord">MAYBE</div>
          <p class="oneliner" id="oneLiner">Pick a spot. We will judge it.</p>

          <div class="statrow">
            <div class="stat">
              <small>Location</small>
              <strong id="locLabel">Near you</strong>
              <div class="sub" id="locSource">Source: Auto.</div>
            </div>
            <div class="stat">
              <small>Right now</small>
              <strong id="tempLine">-</strong>
              <div class="sub" id="feelWind">-</div>
            </div>
          </div>

          <div class="forecast" id="forecastList" aria-label="5-day forecast"></div>

          <div class="left-footer">
            <div class="cta">
              <a class="btn" id="supportBtn" href="https://buymeacoffee.com/hoodieornah" target="_blank" rel="noopener">Support the hoodie science</a>
            </div>
            <div id="unitsLine">Units: Auto</div>
          </div>
        </div>
      </div>

      <!-- Right -->
      <div class="card right-card">
        <div class="card-inner">
          <h2>How do you run?</h2>
          <div class="subhead">Be honest. We can tell.</div>

          <label for="runSelect">Temperature preference</label>
          <select id="runSelect" aria-label="Temperature preference">
            <option value="cold">I run cold</option>
            <option value="normal" selected>Normal</option>
            <option value="hot">I run hot</option>
          </select>

          <label for="manualInput">Manual location (optional)</label>
          <input id="manualInput" list="locList" type="text" placeholder="City, Region, Country or ZIP" autocomplete="off" spellcheck="false" />
          <datalist id="locList"></datalist>

          <div class="form-row">
            <button class="btn secondary" id="spinBtn" type="button">Spin the globe</button>
            <button class="btn secondary" id="gpsBtn" type="button">Use my GPS</button>
          </div>

          <div class="using" aria-label="Current settings">
            <div class="k">Using</div><div class="v" id="usingSource">Auto</div>
            <div class="k">Location</div><div class="v"><span class="pin">üìç</span><span id="usingLocation">Near you</span></div>
            <div class="k">Units</div><div class="v" id="usingUnits">Auto</div>
            <div class="k">Actions</div><div class="v" style="justify-content:flex-end;color:var(--muted2);font-weight:600;">Click the location for details or copy</div>
            <div class="help"></div>
          </div>

          <div class="details" id="detailsDrawer" aria-hidden="true">
            <div class="details-header">
              <b>Details</b>
              <button id="drawerClose" type="button">Close</button>
            </div>
            <div class="details-body">
              <div class="details-title" id="drawerTitle">Select a day for details</div>
              <div class="details-meta" id="drawerMeta">No day selected.</div>
              <div id="drawerContent" style="margin-top:6px;color:var(--muted)"></div>
              <div class="sunrow" id="drawerSun" aria-live="polite"></div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <div class="site-footer">
      <div style="min-width:220px">
        <div style="font-weight:700;color:rgba(255,255,255,.88);">Contact</div>
        <div><a href="mailto:info@hoodieornah.com">info@hoodieornah.com</a></div>
        <div>We read it. Eventually.</div>
      </div>

      <div style="max-width:650px">
        Weather data via Open-Meteo. Geocoding via OpenStreetMap Nominatim.<br />
        This site is for entertainment and mild arguments only. No warranties. Do not sue us because you wore a hoodie in a blizzard.
      </div>
    </div>

  </div>

  <div class="toast" id="toast"></div>

  <div class="modal-backdrop" id="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Location details">
      <header>
        <b>Details</b>
        <button id="closeModalBtn" type="button">Close</button>
      </header>
      <div id="modalContent"></div>
    </div>
  </div>

  <script>
    const el = {
      bigWord: document.getElementById("bigWord"),
      oneLiner: document.getElementById("oneLiner"),
      locLabel: document.getElementById("locLabel"),
      locSource: document.getElementById("locSource"),
      tempLine: document.getElementById("tempLine"),
      feelWind: document.getElementById("feelWind"),
      forecastList: document.getElementById("forecastList"),
      runSelect: document.getElementById("runSelect"),
      manualInput: document.getElementById("manualInput"),
      locList: document.getElementById("locList"),
      spinBtn: document.getElementById("spinBtn"),
      gpsBtn: document.getElementById("gpsBtn"),
      wherePill: document.getElementById("wherePill"),
      pillText: document.getElementById("pillText"),
      pillSpinner: document.getElementById("pillSpinner"),
      unitsLine: document.getElementById("unitsLine"),
      usingSource: document.getElementById("usingSource"),
      usingLocation: document.getElementById("usingLocation"),
      usingUnits: document.getElementById("usingUnits"),
      supportBtn: document.getElementById("supportBtn"),
      loadingOverlay: document.getElementById("loadingOverlay"),
      detailsDrawer: document.getElementById("detailsDrawer"),
      drawerTitle: document.getElementById("drawerTitle"),
      drawerMeta: document.getElementById("drawerMeta"),
      drawerContent: document.getElementById("drawerContent"),
      drawerSun: document.getElementById("drawerSun"),
      drawerClose: document.getElementById("drawerClose"),
      toast: document.getElementById("toast"),
      modalBackdrop: document.getElementById("modalBackdrop"),
      modalContent: document.getElementById("modalContent"),
      closeModalBtn: document.getElementById("closeModalBtn"),
      brandHome: document.getElementById("brandHome"),
      unitAuto: document.getElementById("unitAuto"),
      unitF: document.getElementById("unitF"),
      unitC: document.getElementById("unitC"),
    };

    const CURATED_CITIES = [
      { label: "Tokyo, Japan", lat: 35.6895, lon: 139.6917, cc: "JP" },
      { label: "London, UK", lat: 51.5072, lon: -0.1276, cc: "GB" },
      { label: "Reykjavik, Iceland", lat: 64.1466, lon: -21.9426, cc: "IS" },
      { label: "Cape Town, South Africa", lat: -33.9249, lon: 18.4241, cc: "ZA" },
      { label: "Sydney, Australia", lat: -33.8688, lon: 151.2093, cc: "AU" },
      { label: "Anchorage, Alaska", lat: 61.2181, lon: -149.9003, cc: "US" },
      { label: "Mexico City, Mexico", lat: 19.4326, lon: -99.1332, cc: "MX" },
      { label: "Sao Paulo, Brazil", lat: -23.5505, lon: -46.6333, cc: "BR" },
      { label: "Bangkok, Thailand", lat: 13.7563, lon: 100.5018, cc: "TH" },
      { label: "Oslo, Norway", lat: 59.9139, lon: 10.7522, cc: "NO" },
      { label: "Honolulu, Hawaii", lat: 21.3069, lon: -157.8583, cc: "US" },
      { label: "Vancouver, Canada", lat: 49.2827, lon: -123.1207, cc: "CA" },
      { label: "Dubai, UAE", lat: 25.2048, lon: 55.2708, cc: "AE" },
      { label: "Auckland, New Zealand", lat: -36.8509, lon: 174.7645, cc: "NZ" },
      { label: "Helsinki, Finland", lat: 60.1699, lon: 24.9384, cc: "FI" },
      { label: "Buenos Aires, Argentina", lat: -34.6037, lon: -58.3816, cc: "AR" },
    ];

    const CACHE = new Map();
    const CACHE_TTL_MS = 7 * 60 * 1000;

    const state = loadState() || {
      source: "auto",
      lat: null,
      lon: null,
      placeLabel: "Near you",
      countryCode: null,
      units: "F",
      unitOverride: null,
      run: "normal",
      lastDecision: null,
      pillBehavior: "modal",
    };

    let loading = false;
    let latestForecastMeta = [];
    let selectedForecastIndex = null;

    function saveState(){
      try{
        localStorage.setItem("hoodieornah_state_v2", JSON.stringify(state));
      }catch(e){}
    }
    function loadState(){
      try{
        const raw = localStorage.getItem("hoodieornah_state_v2");
        return raw ? JSON.parse(raw) : null;
      }catch(e){ return null; }
    }

    function setCached(key, val){
      CACHE.set(key, { val, at: Date.now() });
    }
    function getCached(key){
      const hit = CACHE.get(key);
      if (!hit) return null;
      if ((Date.now() - hit.at) > CACHE_TTL_MS) { CACHE.delete(key); return null; }
      return hit.val;
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    function showToast(msg){
      el.toast.textContent = msg;
      el.toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> el.toast.classList.remove("show"), 2200);
    }

    function setLoadingUI(){
      loading = true;
      el.loadingOverlay.classList.add("show");
      el.pillSpinner.style.display = "inline-block";
    }
    function endLoadingUI(){
      loading = false;
      el.loadingOverlay.classList.remove("show");
      el.pillSpinner.style.display = "none";
    }

    function escapeHtml(str){
      return String(str || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function toF(c){ return (c * 9/5) + 32; }
    function toC(f){ return (f - 32) * 5/9; }

    function countryUsesF(cc){
      const set = new Set(["US","BS","BZ","KY","PW","LR","FM","MH"]);
      return cc ? set.has(String(cc).toUpperCase()) : true;
    }

    function fixUnitButtonLabels(){
      el.unitF.textContent = "¬∞F";
      el.unitC.textContent = "¬∞C";
    }

    function setPill(text){
      el.pillText.textContent = normalizeLabel(text);
      adjustPillWidth();
      el.usingLocation.textContent = normalizeLabel(text);
    }

    function adjustPillWidth(){
      const t = el.pillText.textContent || "";
      const approx = Math.min(320, Math.max(120, (t.length * 8) + 64));
      el.wherePill.style.maxWidth = approx + "px";
    }

    function updateSourceUI(){
      const src = state.source;
      el.usingSource.textContent = src === "gps" ? "GPS" : (src === "globe" ? "Globe" : (src === "manual" ? "Manual" : "Auto"));
      el.locSource.textContent = "Source: " + el.usingSource.textContent + ".";
      el.locLabel.textContent = normalizeLabel(state.placeLabel);
      el.usingLocation.textContent = normalizeLabel(state.placeLabel);
      const u = state.unitOverride ? (state.unitOverride === "F" ? "Fahrenheit" : "Celsius") : "Auto";
      el.usingUnits.textContent = u;
      el.unitsLine.textContent = "Units: " + (state.unitOverride ? (state.unitOverride === "F" ? "Fahrenheit" : "Celsius") : "Auto");
    }

    function normalizeLabel(raw){
      if (!raw) return "Near you";
      const cleaned = String(raw).replace(/[\u{1F4CD}\u{1F4CC}\u{1F4CB}üìçüìå\uFE0F]/gu, "").replace(/\s+/g," ").trim();
      if (/^-?\d+(\.\d+)?[¬∞,]/.test(cleaned)) return "Near you";
      return cleaned || "Near you";
    }
    function displayWithPin(label){
      const clean = normalizeLabel(label);
      return "üìç " + clean;
    }

    function formatPlaceFromRev(rev){
      if (!rev) return null;
      const a = rev.address || {};
      const city = a.city || a.town || a.village || a.hamlet || a.municipality || a.locality || a.suburb;
      const regionShort = a.state_code || a.region_code || a.province_code || null;
      const region = regionShort || a.state || a.region || a.province;
      const country = a.country;
      const cc = a.country_code ? String(a.country_code).toUpperCase() : null;

      const parts = [];
      if (city) parts.push(city);
      if (cc === "US" || cc === "CA" || cc === "AU"){
        if (region) parts.push(region);
      } else {
        if (!city && region) parts.push(region);
      }
      if (!parts.length && country) parts.push(country);
      else if (parts.length === 1 && country && cc !== "US" && cc !== "CA" && cc !== "AU") parts.push(country);

      const label = parts.filter(Boolean).join(", ").trim();
      return label || null;
    }

    async function reverseGeocodeToLabel(lat, lon){
      const rev = await reverseGeocode(lat, lon);
      if (!rev) return { label: null, cc: null };
      const cc = rev.address && rev.address.country_code ? String(rev.address.country_code).toUpperCase() : null;
      const label = formatPlaceFromRev(rev) || (rev.display_name ? rev.display_name.split(",").slice(0,2).join(",").trim() : null);
      return { label: label ? normalizeLabel(label) : null, cc };
    }

    async function pickRandomGeocodedSpot(maxAttempts = 10){
      for (let i = 0; i < maxAttempts; i++){
        const lat = (Math.random() * 160) - 80;
        const lon = (Math.random() * 360) - 180;
        try{
          const got = await reverseGeocodeToLabel(lat, lon);
          if (got && got.label && got.label !== "Near you"){
            return { lat, lon, label: got.label, cc: got.cc || null };
          }
        }catch(e){}
      }
      return null;
    }

    async function fetchJson(url, timeoutMs = 12000){
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), timeoutMs);
      try{
        const res = await fetch(url, { signal: ctrl.signal, headers: { "Accept": "application/json" } });
        if (!res.ok) throw new Error("http_" + res.status);
        return await res.json();
      } finally {
        clearTimeout(t);
      }
    }

    async function reverseGeocode(lat, lon){
      const url =
        "https://nominatim.openstreetmap.org/reverse?format=jsonv2&addressdetails=1" +
        "&lat=" + encodeURIComponent(lat) +
        "&lon=" + encodeURIComponent(lon);
      return await fetchJson(url, 12000);
    }

    async function geocodeDisplayName(q){
      const url =
        "https://nominatim.openstreetmap.org/search?format=jsonv2&addressdetails=1&limit=1" +
        "&q=" + encodeURIComponent(q);
      const res = await fetchJson(url, 12000);
      if (!Array.isArray(res) || !res[0]) throw new Error("no_results");
      const item = res[0];
      const label = item.display_name ? item.display_name.split(",").slice(0,2).join(",").trim() : q;
      const cc = item.address && item.address.country_code ? String(item.address.country_code).toUpperCase() : null;
      return {
        lat: parseFloat(item.lat),
        lon: parseFloat(item.lon),
        label: normalizeLabel(label),
        countryCode: cc
      };
    }

    function normalizeForecastResponse(raw, unitsReturned){
      if (!raw || !raw.daily) return null;
      const d = raw.daily;
      const toCIfNeeded = (val) => {
        if (!Number.isFinite(val)) return null;
        return unitsReturned === "fahrenheit" ? toC(val) : val;
      };
      const normalized = {
        time: Array.isArray(d.time) ? d.time.slice(0,7) : [],
        temperature_2m_max_C: Array.isArray(d.temperature_2m_max) ? d.temperature_2m_max.map(v => toCIfNeeded(v)) : [],
        temperature_2m_min_C: Array.isArray(d.temperature_2m_min) ? d.temperature_2m_min.map(v => toCIfNeeded(v)) : [],
        apparent_temperature_max_C: Array.isArray(d.apparent_temperature_max) ? d.apparent_temperature_max.map(v => toCIfNeeded(v)) : [],
        apparent_temperature_min_C: Array.isArray(d.apparent_temperature_min) ? d.apparent_temperature_min.map(v => toCIfNeeded(v)) : [],
        sunrise: Array.isArray(d.sunrise) ? d.sunrise.slice(0,7) : [],
        sunset: Array.isArray(d.sunset) ? d.sunset.slice(0,7) : [],
        weathercode: Array.isArray(d.weathercode) ? d.weathercode.slice(0,7) : []
      };
      return normalized;
    }

    async function fetchForecast(lat, lon, units){
      const key = `forecast:${lat.toFixed(4)},${lon.toFixed(4)}`;
      const cached = getCached(key);
      if (cached) return cached;

      const tempUnit = units === "F" ? "fahrenheit" : "celsius";
      const url =
        "https://api.open-meteo.com/v1/forecast" +
        "?latitude=" + encodeURIComponent(lat) +
        "&longitude=" + encodeURIComponent(lon) +
        "&daily=temperature_2m_max,temperature_2m_min,apparent_temperature_max,apparent_temperature_min,weathercode,sunrise,sunset" +
        "&temperature_unit=" + tempUnit +
        "&timezone=auto&forecast_days=7";

      const raw = await fetchJson(url, 12000);
      const normalized = normalizeForecastResponse(raw, tempUnit);
      if (!normalized) throw new Error("invalid_forecast");
      setCached(key, normalized);
      return normalized;
    }

    async function fetchWeather(lat, lon, units){
      const key = `weather:${lat.toFixed(4)},${lon.toFixed(4)}`;
      const cached = getCached(key);
      if (cached) return cached;

      const tempUnit = units === "F" ? "fahrenheit" : "celsius";
      const windUnit = units === "F" ? "mph" : "kmh";

      const url =
        "https://api.open-meteo.com/v1/forecast" +
        "?latitude=" + encodeURIComponent(lat) +
        "&longitude=" + encodeURIComponent(lon) +
        "&current=temperature_2m,apparent_temperature,wind_speed_10m" +
        "&temperature_unit=" + tempUnit +
        "&windspeed_unit=" + windUnit +
        "&timezone=auto";

      const raw = await fetchJson(url, 12000);
      const cur = raw.current || {};
      const normalized = {
        temperature_C: (units === "F" ? toC(cur.temperature_2m) : cur.temperature_2m),
        apparent_C: (units === "F" ? toC(cur.apparent_temperature) : cur.apparent_temperature),
        wind: cur.wind_speed_10m,
        fetchedAt: Date.now()
      };
      setCached(key, normalized);
      return normalized;
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function hoodieDecision(tempC, wind, runPref){
      const feelsC = tempC;
      const windFactor = clamp((wind || 0), 0, 28) * 0.06;
      let adj = feelsC - (windFactor * 4.0);
      if (runPref === "cold") adj -= 2.0;
      if (runPref === "hot") adj += 2.0;

      if (adj <= -2) return { word:"HOODIE", band:"cold_snap" };
      if (adj <= 6) return { word:"HOODIE", band:"hoodie_prime" };
      if (adj <= 12) return { word:"MAYBE", band:"maybe_cool" };
      if (adj <= 18) return { word:"MAYBE", band:"maybe_warm" };
      if (adj <= 24) return { word:"NAH", band:"nah_warm" };
      return { word:"NAH", band:"nah_hot" };
    }

    const QUIPS = {
      HOODIE: [
        "Yes. Hoodie plus life choices that include layers.",
        "Yep. Hoodie weather. Enjoy the smug warmth.",
        "Hoodie time. Your ears will send a thank-you note.",
        "Put the hood up and pretend you are mysterious.",
        "Wear the hoodie. Regret is for bare wrists.",
        "This is hoodie weather and it knows it.",
        "Hoodie recommended. Bonus points for pockets.",
        "If you skip the hoodie, you will think about it all day.",
        "Hoodie season. Lean into it.",
        "Hoodie on. The wind is being rude.",
        "Hoodie is the correct moral choice here.",
        "You want sleeves and plausible deniability. Hoodie.",
        "Yes hoodie. The air is spicy.",
        "Hoodie now. Your future self is grateful.",
        "Hoodie. You can still look cool while surviving.",
        "Hoodie. Do not let the forecast bully you.",
        "Hoodie is the safe play. Do not overthink it.",
        "Hoodie weather. Proceed with confidence."
      ],
      MAYBE: [
        "Could go either way. Hoodie if you like options.",
        "Borderline. Hoodie for the shade, nah for the sun.",
        "A true toss-up. Bring the hoodie just to feel powerful.",
        "This is a vibe check, not a science. Maybe hoodie.",
        "You can raw-dog it, or you can hoodie. Your call.",
        "Maybe hoodie. Depends on your tolerance for drama.",
        "Not cold, not warm. Annoyingly in-between.",
        "Hoodie if you will be outside longer than five minutes.",
        "Maybe hoodie. The wind might try something.",
        "This is the gray area. Dress like you have plans.",
        "Coin-flip weather. Hoodie is the insurance policy.",
        "You will be fine either way. Probably.",
        "Maybe hoodie. Mostly for the pockets.",
        "This is prime 'start with hoodie, regret later' territory.",
        "Maybe. If you run cold, hoodie. If you run hot, nah.",
        "Maybe. You will argue with yourself in the mirror.",
        "Borderline. Hoodie for mornings, nah for afternoons.",
        "Maybe hoodie. Commit to ambiguity."
      ],
      NAH: [
        "Nope. Hoodie would be a personal attack on your pores.",
        "Hoodie? Only if you are trying to escape the sun by staying inside.",
        "Nah. Let your shoulders live a little.",
        "Skip the hoodie. You are not in a music video.",
        "Nah. Hoodie would be overachieving.",
        "No hoodie. Hydrate and pretend you are fine.",
        "Nah. If you wear one, you will unzip it instantly.",
        "Hoodie is not needed. Save it for the thermostat wars.",
        "No hoodie. The air is doing enough already.",
        "Nah. You will feel silly in 30 seconds.",
        "Skip it. This is short-sleeve confidence weather.",
        "Nah. Your hood will just become a backpack.",
        "No hoodie. Your future sweat glands object.",
        "Nah. Hoodie is a trap right now.",
        "Skip it. The sun is winning.",
        "Nah. Hoodie is too dramatic for this temp.",
        "No hoodie. Keep it simple.",
        "Nah. You will survive without the comfort blanket."
      ]
    };

    function pickUniqueQuip(word, usedSet){
      const pool = (QUIPS[word] || []).slice();
      for (let i = pool.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = pool[i]; pool[i] = pool[j]; pool[j] = tmp;
      }
      for (const q of pool){
        if (!usedSet.has(q)) { usedSet.add(q); return q; }
      }
      const fallback = pool[0] || "";
      usedSet.add(fallback);
      return fallback;
    }

    function fmtTemp(tempC, units){
      if (!Number.isFinite(tempC)) return "-";
      const v = units === "F" ? Math.round(toF(tempC)) : Math.round(tempC);
      return v + "¬∞" + units;
    }

    function fmtWind(wind, units){
      if (!Number.isFinite(wind)) return "--";
      const u = units === "F" ? "mph" : "km/h";
      return Math.round(wind) + " " + u;
    }

    function iconFor(code){
      const c = Number(code);
      if ([0].includes(c)) return { text:"Clear", glyph:"‚òÄÔ∏è" };
      if ([1,2].includes(c)) return { text:"Partly cloudy", glyph:"‚õÖ" };
      if ([3].includes(c)) return { text:"Overcast", glyph:"‚òÅÔ∏è" };
      if ([45,48].includes(c)) return { text:"Fog", glyph:"üå´Ô∏è" };
      if ([51,53,55,56,57].includes(c)) return { text:"Drizzle", glyph:"üå¶Ô∏è" };
      if ([61,63,65,66,67].includes(c)) return { text:"Rain", glyph:"üåßÔ∏è" };
      if ([71,73,75,77].includes(c)) return { text:"Snow", glyph:"üå®Ô∏è" };
      if ([80,81,82].includes(c)) return { text:"Showers", glyph:"üåßÔ∏è" };
      if ([95,96,99].includes(c)) return { text:"Thunderstorm", glyph:"‚õàÔ∏è" };
      return { text:"Weather", glyph:"üå°Ô∏è" };
    }

    function svgFor(code){
      const i = iconFor(code);
      const t = i.text;
      const glyph = i.glyph;
      const svg = `
        <svg viewBox="0 0 64 64" aria-hidden="true" focusable="false">
          <rect x="1" y="1" width="62" height="62" rx="18" fill="rgba(255,255,255,.06)" stroke="rgba(255,255,255,.12)"></rect>
          <text x="32" y="40" text-anchor="middle" font-size="28">${glyph}</text>
        </svg>
      `;
      return { svg, text: t };
    }

    function buildForecastMeta(forecast){
      const out = [];
      const usedQuips = new Set();
      const times = forecast.time || [];
      for (let i = 0; i < Math.min(5, times.length); i++){
        const day = new Date(times[i] + "T00:00:00");
        const dayLabel = day.toLocaleDateString(undefined, { weekday:"short", month:"short", day:"numeric" });
        const tmaxC = forecast.temperature_2m_max_C[i];
        const tminC = forecast.temperature_2m_min_C[i];
        const amaxC = forecast.apparent_temperature_max_C[i];
        const aminC = forecast.apparent_temperature_min_C[i];
        const code = forecast.weathercode[i];

        const avgApp = (Number.isFinite(amaxC) && Number.isFinite(aminC)) ? ((amaxC + aminC)/2) : (Number.isFinite(tmaxC) ? tmaxC : 10);
        const d = hoodieDecision(avgApp, null, state.run || "normal");
        const line = pickUniqueQuip(d.word, usedQuips);

        out.push({
          dayLabel,
          tmaxC, tminC, amaxC, aminC,
          weatherCode: code,
          dec: { word: d.word, line }
        });
      }
      return out;
    }

    function renderForecast(forecast, opts = {}){
      latestForecastMeta = buildForecastMeta(forecast);
      el.forecastList.innerHTML = "";
      const displayUnits = state.unitOverride || state.units;

      latestForecastMeta.forEach((m, idx) => {
        const icon = svgFor(m.weatherCode);
        const maxT = Number.isFinite(m.tmaxC) ? fmtTemp(m.tmaxC, displayUnits) : "--";
        const minT = Number.isFinite(m.tminC) ? fmtTemp(m.tminC, displayUnits) : "--";

        const div = document.createElement("div");
        div.className = "forecast-item";
        div.tabIndex = 0;
        div.setAttribute("role","button");
        div.setAttribute("aria-label", `Details for ${m.dayLabel}`);
        div.innerHTML = `
          <div class="forecast-top">
            <b>${escapeHtml(m.dayLabel)}</b>
            ${icon.svg}
          </div>
          <div class="forecast-mid">${escapeHtml(maxT)} / ${escapeHtml(minT)} <strong>${escapeHtml(m.dec.word)}</strong></div>
          <div class="forecast-line">${escapeHtml(m.dec.line)}</div>
        `;
        el.forecastList.appendChild(div);
      });

      const shouldAutoSelect = opts.forceSelectFirst || selectedForecastIndex == null;
      if (latestForecastMeta.length && shouldAutoSelect){
        selectForecastIndex(0, { openDrawerNow: true });
      } else if (selectedForecastIndex != null && latestForecastMeta[selectedForecastIndex]){
        selectForecastIndex(selectedForecastIndex);
      } else if (!latestForecastMeta.length){
        closeDrawer();
      }
    }

    function renderResultFromNormalized(cur){
      const displayUnits = state.unitOverride || state.units;
      const temp = fmtTemp(cur.temperature_C, displayUnits);
      const feels = fmtTemp(cur.apparent_C, displayUnits);

      el.tempLine.textContent = temp;
      el.feelWind.textContent = `Feels like: ${feels} | Wind: ${fmtWind(cur.wind, displayUnits)}`;

      const d = hoodieDecision(cur.apparent_C, cur.wind, state.run || "normal");
      const word = d.word;
      const line = pickUniqueQuip(word, new Set()); // single pick for the hero line, no need to compare

      state.lastDecision = { word, line };
      saveState();
      el.bigWord.textContent = word;
      el.oneLiner.textContent = line;
    }

    async function updateWeatherFromLatLon(lat, lon, label, countryCode, source, opts = {}){
      state.lat = lat;
      state.lon = lon;
      state.source = source || state.source;

      const effectiveUnits = state.unitOverride || state.units;
      state.placeLabel = normalizeLabel(label || state.placeLabel);
      state.countryCode = countryCode || state.countryCode;

      setPill(state.placeLabel);
      updateSourceUI();
      saveState();

      try{
        const [cur, forecast] = await Promise.all([
          fetchWeather(lat, lon, effectiveUnits),
          fetchForecast(lat, lon, effectiveUnits),
        ]);
        renderResultFromNormalized(cur);
        renderForecast(forecast, { forceSelectFirst: !!opts.forceSelectFirst });

        if (countryCode && !state.unitOverride){
          const should = countryUsesF(countryCode) ? "F" : "C";
          if (should !== state.units){
            state.units = should;
            saveState();
            setUnitControlButtons();
            renderResultFromNormalized(cur);
            renderForecast(forecast, { forceSelectFirst: true });
            updateSourceUI();
          }
        }
      } finally {
        endLoadingUI();
      }
    }

    function popNextSpinIndex(){
      const key = "hoodieornah_spinbag_v1";
      let bag = [];
      try{ bag = JSON.parse(localStorage.getItem(key) || "[]"); }catch(e){}
      if (!Array.isArray(bag) || bag.length !== CURATED_CITIES.length){
        bag = Array.from({ length: CURATED_CITIES.length }, (_, i) => i);
      }
      const idx = Math.floor(Math.random() * bag.length);
      const pick = bag.splice(idx, 1)[0];
      try{ localStorage.setItem(key, JSON.stringify(bag)); }catch(e){}
      return pick;
    }

    async function tryAutoLocation(){
      state.source = "auto";
      updateSourceUI();
      setPill("Near you");

      if (!navigator.geolocation){
        showToast("No GPS here. Type a city instead.");
        return;
      }

      setPill("Locating...");
      setLoadingUI();

      const opts = { enableHighAccuracy: false, timeout: 6500, maximumAge: 600000 };
      navigator.geolocation.getCurrentPosition(async (pos) => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;

        await updateWeatherFromLatLon(lat, lon, "Near you", null, "auto", { forceSelectFirst: true });

        try{
          const got = await reverseGeocodeToLabel(lat, lon);
          if (got && got.label){
            state.placeLabel = got.label;
            state.countryCode = got.cc || state.countryCode;
            setPill(state.placeLabel);
            updateSourceUI();
            if (!state.unitOverride && got.cc){
              const newUnits = countryUsesF(got.cc) ? "F" : "C";
              if (newUnits !== state.units){
                state.units = newUnits;
                setUnitControlButtons();
                await updateWeatherFromLatLon(lat, lon, state.placeLabel, state.countryCode, "auto", { forceSelectFirst: true });
              }
            }
          } else {
            setPill("Near you");
          }
        }catch(e){
          setPill("Near you");
        }

      }, () => {
        setPill("Near you");
        endLoadingUI();
      }, opts);
    }

    async function onUseGPS(){
      if (!navigator.geolocation){ showToast("No GPS available in this browser."); return; }
      state.source = "gps";
      updateSourceUI();
      setPill("Locating...");
      setLoadingUI();

      const opts = { enableHighAccuracy: true, timeout: 9000, maximumAge: 0 };

      navigator.geolocation.getCurrentPosition(async (pos) => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;

        await updateWeatherFromLatLon(lat, lon, "Near you", null, "gps", { forceSelectFirst: true });

        try{
          const got = await reverseGeocodeToLabel(lat, lon);
          const cc = got && got.cc ? got.cc : null;
          const label = got && got.label ? got.label : null;

          if (cc) state.countryCode = cc || state.countryCode;
          if (label){
            state.placeLabel = label;
            setPill(state.placeLabel);
            updateSourceUI();
            if (!state.unitOverride){
              const newUnits = cc ? (countryUsesF(cc) ? "F" : "C") : state.units;
              if (newUnits !== state.units){
                await updateWeatherFromLatLon(lat, lon, state.placeLabel, state.countryCode, "gps", { forceSelectFirst: true });
              }
            }
          }
        }catch(err){ console.warn("Reverse geocode failed:", err); }
      }, (err) => {
        console.warn("GPS failed:", err);
        setPill("Near you");
        el.bigWord.textContent = "MAYBE";
        el.oneLiner.textContent = "Location failed. Type a city and we will still judge it.";
        showToast(err && err.code === 1 ? "Location access denied" : "GPS error or timeout");
        endLoadingUI();
      }, opts);
    }

    async function onSpinGlobe(){
      state.source = "globe";
      updateSourceUI();
      setPill("Spinning...");
      setLoadingUI();

      await sleep(320);

      const idx = popNextSpinIndex();
      const pick = CURATED_CITIES[idx];

      if (!pick){
        const got = await pickRandomGeocodedSpot(12);
        if (got){
          state.placeLabel = got.label;
          state.countryCode = got.cc || null;
          if (!state.unitOverride && state.countryCode) state.units = countryUsesF(state.countryCode) ? "F" : "C";
          setPill(state.placeLabel);
          await updateWeatherFromLatLon(got.lat, got.lon, state.placeLabel, state.countryCode, "globe", { forceSelectFirst: true });
          return;
        }

        state.placeLabel = "Somewhere on Earth";
        state.countryCode = null;
        setPill(state.placeLabel);
        await updateWeatherFromLatLon((Math.random()*160)-80, (Math.random()*360)-180, state.placeLabel, null, "globe", { forceSelectFirst: true });
        return;
      }

      let label = pick.label ? normalizeLabel(pick.label) : null;
      let cc = pick.cc ? String(pick.cc).toUpperCase() : null;

      if (!label){
        try{
          const got = await reverseGeocodeToLabel(pick.lat, pick.lon);
          if (got && got.label) label = got.label;
          if (got && got.cc) cc = got.cc;
        }catch(e){}
      }

      state.placeLabel = label || "Somewhere on Earth";
      state.countryCode = cc || state.countryCode;

      if (!state.unitOverride && state.countryCode) state.units = countryUsesF(state.countryCode) ? "F" : "C";
      setPill(state.placeLabel);
      await updateWeatherFromLatLon(pick.lat, pick.lon, state.placeLabel, cc, "globe", { forceSelectFirst: true });
    }

    let suggestTimer = null, suggestAbort = null;
    function suggestLocations(q){
      if (loading) return;
      const s = (q||"").trim();
      if (s.length < 3){ el.locList.innerHTML = ""; return; }
      if (suggestAbort){ try{ suggestAbort.abort(); }catch(e){} }
      if (suggestTimer) clearTimeout(suggestTimer);
      suggestTimer = setTimeout(async ()=>{
        suggestAbort = new AbortController();
        const url = "https://nominatim.openstreetmap.org/search?format=jsonv2&addressdetails=1&limit=8&q=" + encodeURIComponent(s);
        try{
          const res = await fetch(url, { signal: suggestAbort.signal, headers: { "Accept":"application/json" } });
          if (!res.ok) return;
          const data = await res.json();

          const seen = new Set();
          const opts = [];
          for (const item of (data || [])){
            const v = (item && item.display_name) ? String(item.display_name) : "";
            if (!v) continue;
            if (seen.has(v)) continue;
            seen.add(v);
            opts.push(v);
            if (opts.length >= 6) break;
          }

          el.locList.innerHTML = opts.map(v => `<option value="${escapeHtml(v)}"></option>`).join("");
        }catch(e){} finally { suggestAbort = null; }
      }, 260);
    }

    function suppressDatalistOnce(){
      try{
        el.locList.innerHTML = "";
        const curList = el.manualInput.getAttribute("list");
        if (!curList) return;
        el.manualInput.removeAttribute("list");
        setTimeout(() => {
          el.manualInput.setAttribute("list", curList);
        }, 400);
      }catch(e){}
    }

    el.manualInput.addEventListener('input', () => {
      suggestLocations(el.manualInput.value);
      const val = (el.manualInput.value || "").trim();
      if (!val) return;

      const opts = Array.from(el.locList.options || []).map(o => o.value);
      if (opts.includes(val)){
        setTimeout(() => {
          if (!loading) onManualSubmit(true);
        }, 6);
      }
    });

    async function onManualSubmit(fromPick){
      const q = (el.manualInput.value || "").trim();
      if (!q){ showToast("Type a place first."); return; }
      state.source = "manual";
      updateSourceUI();
      setPill("Searching...");
      setLoadingUI();
      try{
        const g = await geocodeDisplayName(q);
        await updateWeatherFromLatLon(g.lat, g.lon, g.label, g.countryCode, "manual", { forceSelectFirst: true });

        el.manualInput.value = g.label;
        el.manualInput.blur();
        suppressDatalistOnce();
        if (fromPick) showToast("Locked in: " + g.label);
      }catch(e){
        console.error(e);
        el.bigWord.textContent = "MAYBE";
        el.oneLiner.textContent = "Could not find that place. Try a nearby city or add a country.";
        showToast("No results for that location.");
        setPill("Near you");
        endLoadingUI();
      }
    }

    function openDrawer(){
      el.detailsDrawer.setAttribute('aria-hidden', 'false');
    }
    function closeDrawer(){
      el.detailsDrawer.setAttribute('aria-hidden', 'true');
      el.drawerTitle.textContent = "Select a day for details";
      el.drawerMeta.textContent = "No day selected.";
      el.drawerContent.innerHTML = "";
      el.drawerSun.innerHTML = "";
      selectedForecastIndex = null;
      Array.from(el.forecastList.children).forEach(card => card.classList.remove("selected"));
    }

    function showDayInDrawer(meta, idx){
      if (!meta) return;
      openDrawer();
      el.drawerTitle.textContent = meta.dayLabel;

      const displayUnits = state.unitOverride || state.units;
      const maxDisplay = Number.isFinite(meta.tmaxC) ? (displayUnits === "F" ? Math.round(toF(meta.tmaxC)) : Math.round(meta.tmaxC)) : null;
      const minDisplay = Number.isFinite(meta.tminC) ? (displayUnits === "F" ? Math.round(toF(meta.tminC)) : Math.round(meta.tminC)) : null;
      const feelMax = Number.isFinite(meta.amaxC) ? (displayUnits === "F" ? Math.round(toF(meta.amaxC)) : Math.round(meta.amaxC)) : null;
      const feelMin = Number.isFinite(meta.aminC) ? (displayUnits === "F" ? Math.round(toF(meta.aminC)) : Math.round(meta.aminC)) : null;
      const icon = svgFor(meta.weatherCode);

      el.drawerMeta.innerHTML = `${icon.svg} <span style="font-weight:700;color:var(--text)">${escapeHtml(icon.text)}</span>`;

      const fkey = (Number.isFinite(state.lat) && Number.isFinite(state.lon)) ? `forecast:${state.lat.toFixed(4)},${state.lon.toFixed(4)}` : null;
      const forecast = fkey ? getCached(fkey) : null;

      const sunriseRaw = (forecast && Array.isArray(forecast.sunrise)) ? forecast.sunrise[idx] : null;
      const sunsetRaw  = (forecast && Array.isArray(forecast.sunset))  ? forecast.sunset[idx]  : null;

      const fmtClock = (v) => {
        if (!v) return "--";
        const d = new Date(v);
        if (Number.isNaN(d.getTime())) return "--";
        return d.toLocaleTimeString(undefined, { hour: "numeric", minute: "2-digit" });
      };

      el.drawerContent.innerHTML = `
        <div style="margin-top:6px;display:grid;gap:6px;line-height:1.35;">
          <div><strong style="color:var(--text)">Temps:</strong> ${escapeHtml(maxDisplay != null ? (maxDisplay + "¬∞" + displayUnits) : "--")} / ${escapeHtml(minDisplay != null ? (minDisplay + "¬∞" + displayUnits) : "--")}</div>
          <div><strong style="color:var(--text)">Feels:</strong> ${escapeHtml(feelMax != null ? (feelMax + "¬∞" + displayUnits) : "--")} / ${escapeHtml(feelMin != null ? (feelMin + "¬∞" + displayUnits) : "--")}</div>
          <div><strong style="color:var(--text)">Verdict:</strong> ${escapeHtml(meta.dec.word)}</div>
          <div style="color:var(--muted2);">${escapeHtml(meta.dec.line)}</div>
        </div>
      `;

      el.drawerSun.innerHTML = `
        <div class="sunbox">
          <span class="sunlabel">Sunrise</span>
          <span class="sunvalue">${escapeHtml(fmtClock(sunriseRaw))}</span>
        </div>
        <div class="sunbox">
          <span class="sunlabel">Sunset</span>
          <span class="sunvalue">${escapeHtml(fmtClock(sunsetRaw))}</span>
        </div>
      `;
    }

    function selectForecastIndex(idx, opts = {}){
      if (!latestForecastMeta[idx]) return;
      selectedForecastIndex = idx;
      Array.from(el.forecastList.children).forEach((card, i) => {
        card.classList.toggle("selected", i === idx);
      });
      showDayInDrawer(latestForecastMeta[idx], idx);
      if (opts.openDrawerNow) openDrawer();
    }

    el.forecastList.addEventListener('click', (ev) => {
      const item = ev.target.closest('.forecast-item');
      if (!item) return;
      const idx = Array.from(el.forecastList.children).indexOf(item);
      selectForecastIndex(idx);
    });
    el.forecastList.addEventListener('keydown', (ev) => {
      if (ev.key === "Enter" || ev.key === " ") {
        const item = ev.target.closest('.forecast-item');
        if (!item) return;
        ev.preventDefault();
        const idx = Array.from(el.forecastList.children).indexOf(item);
        selectForecastIndex(idx);
      }
    });

    el.drawerClose.addEventListener('click', closeDrawer);

    function openModal(titleHtml){
      el.modalBackdrop.style.display = "flex";
      el.modalBackdrop.setAttribute("aria-hidden", "false");
      el.modalContent.innerHTML = titleHtml;
    }
    function closeModal(){ el.modalBackdrop.style.display = "none"; el.modalBackdrop.setAttribute("aria-hidden", "true"); }

    el.wherePill.addEventListener("click", async ()=>{
      const full = normalizeLabel(state.placeLabel || "Near you");
      if (state.pillBehavior === "copy"){
        try{
          await navigator.clipboard.writeText(full);
          showToast("Location copied to clipboard");
        }catch(e){
          showToast(full);
        }
        return;
      }
      const html = `<div><strong>${escapeHtml(displayWithPin(full))}</strong><pre style="margin-top:8px;">${escapeHtml((state.lastDecision && state.lastDecision.word) || "")} - ${escapeHtml(state.placeLabel || "")}\n${el.tempLine.textContent || ""}\n${el.oneLiner.textContent || ""}</pre></div>`;
      openModal(html);
    });
    el.wherePill.addEventListener("keydown", (e)=>{ if (e.key === "Enter" || e.key === " ") { e.preventDefault(); el.wherePill.click(); } });

    el.closeModalBtn.addEventListener("click", closeModal);
    el.modalBackdrop.addEventListener("click", (e)=>{ if (e.target === el.modalBackdrop) closeModal(); });

    el.modalContent.addEventListener("dblclick", ()=>{
      state.pillBehavior = (state.pillBehavior === "modal") ? "copy" : "modal";
      saveState();
      showToast("Pill behavior: " + (state.pillBehavior === "modal" ? "details modal" : "copy-on-click"));
    });

    function setUnitControlButtons(){
      const auto = !state.unitOverride;
      el.unitAuto.setAttribute("aria-pressed", String(auto));
      el.unitF.setAttribute("aria-pressed", String(state.unitOverride === "F"));
      el.unitC.setAttribute("aria-pressed", String(state.unitOverride === "C"));
    }
    function applyUnitSelection(newSel){
      state.unitOverride = newSel;
      if (state.unitOverride) state.units = state.unitOverride;
      else state.units = state.countryCode ? (countryUsesF(state.countryCode) ? "F" : "C") : state.units;
      setUnitControlButtons();
      saveState();
      if (Number.isFinite(state.lat) && Number.isFinite(state.lon)){
        const wkey = `weather:${state.lat.toFixed(4)},${state.lon.toFixed(4)}`;
        const fkey = `forecast:${state.lat.toFixed(4)},${state.lon.toFixed(4)}`;
        const cachedCur = getCached(wkey);
        const cachedF = getCached(fkey);
        if (cachedCur) renderResultFromNormalized(cachedCur);
        if (cachedF) renderForecast(cachedF, { forceSelectFirst: selectedForecastIndex == null });
        if (!cachedCur || !cachedF){
          updateWeatherFromLatLon(state.lat, state.lon, state.placeLabel, state.countryCode, state.source, { forceSelectFirst: selectedForecastIndex == null });
        }
      } else {
        updateSourceUI();
      }
    }

    el.manualInput.addEventListener('keydown', (e) => { if (e.key === "Enter"){ e.preventDefault(); onManualSubmit(false); } });
    el.spinBtn.addEventListener("click", onSpinGlobe);
    el.gpsBtn.addEventListener("click", onUseGPS);
    el.brandHome.addEventListener("click", () => { el.manualInput.value = ""; suppressDatalistOnce(); tryAutoLocation(); });
    el.unitAuto.addEventListener("click", () => applyUnitSelection(null));
    el.unitF.addEventListener("click", () => applyUnitSelection("F"));
    el.unitC.addEventListener("click", () => applyUnitSelection("C"));

    function init(){
      fixUnitButtonLabels();
      el.runSelect.value = state.run || "normal";
      el.runSelect.addEventListener("change", () => {
        state.run = el.runSelect.value || "normal";
        saveState();
        if (Number.isFinite(state.lat) && Number.isFinite(state.lon)){
          const wkey = `weather:${state.lat.toFixed(4)},${state.lon.toFixed(4)}`;
          const fkey = `forecast:${state.lat.toFixed(4)},${state.lon.toFixed(4)}`;
          const cachedCur = getCached(wkey);
          const cachedF = getCached(fkey);
          if (cachedCur) renderResultFromNormalized(cachedCur);
          if (cachedF) renderForecast(cachedF, { forceSelectFirst: true });
          if (!cachedCur || !cachedF) updateWeatherFromLatLon(state.lat, state.lon, state.placeLabel, state.countryCode, state.source, { forceSelectFirst: true });
        }
      });

      setUnitControlButtons();
      setPill(state.placeLabel || "Near you");
      updateSourceUI();

      if (Number.isFinite(state.lat) && Number.isFinite(state.lon)){
        if (state.lastDecision && state.lastDecision.word){
          el.bigWord.textContent = state.lastDecision.word;
          el.oneLiner.textContent = state.lastDecision.line || "";
          updateSourceUI();
          updateWeatherFromLatLon(state.lat, state.lon, state.placeLabel, state.countryCode, state.source, { forceSelectFirst: true });
        } else {
          updateWeatherFromLatLon(state.lat, state.lon, state.placeLabel, state.countryCode, state.source, { forceSelectFirst: true });
        }
      } else {
        tryAutoLocation();
      }

      adjustPillWidth();
      window.addEventListener("resize", adjustPillWidth);
    }

    init();
  </script>
</body>
</html>
