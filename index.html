<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hoodie or Nah</title>
  <meta name="description" content="Settle the hoodie debate. Hoodie, maybe, or nah based on your local weather." />
  <meta name="theme-color" content="#0b0b0f" />

  <!-- Favicons / App Icons -->
  <link rel="icon" href="/favicon.ico" sizes="any" />
  <link rel="icon" type="image/png" href="/favicon-32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/favicon-16.png" sizes="16x16" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180" />
  <link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192" />
  <link rel="icon" type="image/png" href="/android-chrome-512x512.png" sizes="512x512" />

  <style>
    :root{
      --bg:#0b0b0f;
      --panel:#0f1016;
      --border:rgba(255,255,255,.10);
      --border2:rgba(255,255,255,.14);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.62);
      --muted2:rgba(255,255,255,.48);
      --shadow:0 18px 60px rgba(0,0,0,.55);
      --radius:22px;
      --radius2:28px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    html{color-scheme: dark}
    body{
      margin:0;
      font-family:var(--font);
      background:
        radial-gradient(1200px 600px at 10% 0%, rgba(120,160,255,.12), transparent 45%),
        radial-gradient(900px 500px at 90% 20%, rgba(255,255,255,.06), transparent 55%),
        var(--bg);
      color:var(--text);
    }

    .wrap{
      max-width: 1280px;
      margin: 0 auto;
      padding: 18px;
      position: relative;
    }

    body.is-frozen .wrap::before{
      content:"";
      position:absolute;
      inset:-12px -10px auto -10px;
      height: 220px;
      pointer-events:none;
      background:
        radial-gradient(700px 160px at 20% 10%, rgba(160,190,255,.10), transparent 55%),
        radial-gradient(560px 140px at 85% 10%, rgba(255,255,255,.08), transparent 60%);
      filter: blur(8px);
      opacity: .9;
    }
    body.is-frozen main{
      box-shadow: 0 18px 60px rgba(0,0,0,.55), 0 0 40px rgba(140,170,255,.08);
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 12px 14px;
      border:1px solid var(--border);
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      position: sticky;
      top: 14px;
      backdrop-filter: blur(10px);
      z-index: 5;
      gap: 12px;
    }

    .brand{
      display:flex;
      align-items:center;
      gap: 12px;
      min-width: 0;
    }

    .brand-btn{
      width: 64px;
      height: 64px;
      border-radius: 999px;
      border: 1px solid var(--border2);
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.10), rgba(255,255,255,.02));
      display:grid;
      place-items:center;
      padding:0;
      cursor:pointer;
      transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease;
      box-shadow: 0 8px 28px rgba(0,0,0,.45);
      overflow:hidden;
    }
    .brand-btn:hover{
      transform: translateY(-1px);
      border-color: rgba(140,170,255,.35);
      box-shadow: 0 10px 34px rgba(0,0,0,.55), 0 0 26px rgba(120,160,255,.14);
    }
    .brand-btn img{
      width: 48px;
      height: 48px;
      display:block;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.55));
      border-radius: 12px;
    }

    .wordmark{
      display:flex;
      flex-direction:column;
      line-height:1.05;
      min-width:0;
    }
    .wordmark .title{
      font-size: 20px;
      font-weight: 780;
      letter-spacing: .2px;
      white-space: nowrap;
    }
    .wordmark .tag{
      font-size: 11px;
      color: var(--muted2);
      letter-spacing: .2px;
      margin-top: 3px;
    }

    .header-right{
      display:flex;
      align-items:center;
      gap: 12px;
    }

    .pill{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--border2);
      background: rgba(255,255,255,.03);
      color: var(--text);
      font-weight: 650;
      letter-spacing: .2px;
      user-select:none;
      max-width: 46%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .pill .dot{
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.32);
      box-shadow: 0 0 0 4px rgba(255,255,255,.04);
      flex: 0 0 auto;
    }
    .pill.frozen{
      border-color: rgba(255,255,255,.18);
      background: rgba(255,255,255,.02);
      color: rgba(255,255,255,.78);
      cursor: default;
    }

    .units-seg{
      display:inline-flex;
      border-radius: 999px;
      background: rgba(255,255,255,.02);
      border: 1px solid rgba(255,255,255,.06);
      padding: 4px;
      gap: 6px;
      align-items:center;
      font-size: 13px;
    }
    .units-seg button{
      padding: 6px 10px;
      border-radius: 999px;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      font-weight: 700;
    }
    .units-seg button[aria-pressed="true"]{
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 999px;
    }

    .spinner{
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,.24);
      border-top-color: rgba(255,255,255,.82);
      animation: spin .75s linear infinite;
      flex: 0 0 auto;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    main{
      margin-top: 16px;
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
      box-shadow: var(--shadow);
      padding: 16px;
      transition: box-shadow .22s ease;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.55fr 1fr;
      gap: 16px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
      .pill{max-width: 60%}
    }

    .card{
      border-radius: var(--radius);
      border: 1px solid var(--border2);
      background:
        radial-gradient(900px 500px at 10% 0%, rgba(120,160,255,.10), transparent 42%),
        radial-gradient(700px 420px at 85% 10%, rgba(255,255,255,.07), transparent 50%),
        rgba(0,0,0,.22);
      padding: 18px;
      min-height: 390px;
      position:relative;
      overflow:hidden;
    }

    .card-right{
      border-radius: var(--radius);
      border: 1px solid var(--border2);
      background: rgba(0,0,0,.18);
      padding: 18px;
      min-height: 390px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    .big{
      font-size: 86px;
      font-weight: 900;
      letter-spacing: .6px;
      margin: 8px 0 6px;
      transition: opacity .22s ease, transform .18s ease;
      will-change: opacity, transform;
    }
    .big.fade{
      opacity: 0;
      transform: translateY(6px) scale(.995);
    }
    @media (max-width: 560px){
      .big{font-size: 56px}
    }
    .sub{
      color: var(--muted);
      font-size: 16px;
      margin: 0 0 10px;
      max-width: 52ch;
      transition: opacity .22s ease, transform .18s ease;
    }

    .divider{
      height:1px;
      background: rgba(255,255,255,.10);
      margin: 16px 0 12px;
    }

    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 6px;
    }
    @media (max-width: 560px){
      .stats{grid-template-columns:1fr}
    }

    .stat{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      padding: 12px 12px;
    }
    .stat .k{
      font-size: 12px;
      color: var(--muted2);
      font-weight: 750;
      letter-spacing: .2px;
      margin-bottom: 6px;
    }
    .stat .v{
      font-size: 16px;
      font-weight: 820;
      letter-spacing: .2px;
    }
    .stat .s{
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
      line-height: 1.35;
    }

    label{
      display:block;
      font-size: 13px;
      color: var(--muted);
      margin: 10px 0 8px;
      font-weight: 650;
    }

    select, input{
      width:100%;
      padding: 12px 14px;
      border-radius: 999px;
      border: 1px solid var(--border2);
      background: rgba(255,255,255,.03);
      color: var(--text);
      outline: none;
      font-size: 14px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.15);
    }
    input::placeholder{color: rgba(255,255,255,.35)}
    select{
      color-scheme: dark;
      background-color: rgba(255,255,255,.03);
    }
    select option{
      background: #0f1016;
      color: rgba(255,255,255,.92);
    }

    .btn-row{
      display:flex;
      gap: 10px;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    button{
      padding: 12px 14px;
      border-radius: 999px;
      border: 1px solid var(--border2);
      background: rgba(255,255,255,.04);
      color: var(--text);
      font-weight: 740;
      letter-spacing: .2px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease, opacity .12s ease;
    }
    button:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,.22);
      background: rgba(255,255,255,.06);
    }
    button:active{transform: translateY(0px) scale(.99)}
    button:disabled{
      opacity:.48;
      cursor:not-allowed;
      transform:none;
    }

    .mini{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      border-radius: 18px;
      padding: 12px 12px;
      margin-top: 6px;
    }
    .mini .row{
      display:flex;
      justify-content:space-between;
      gap: 12px;
      align-items:flex-start;
      padding: 6px 2px;
      color: var(--muted);
      font-weight: 650;
      font-size: 13px;
    }
    .mini .row strong{
      color: var(--text);
      font-weight: 820;
    }

    .in-card-footer{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin-top: 14px;
      color: var(--muted);
      font-weight: 650;
      padding: 2px 2px 0;
      flex-wrap: wrap;
    }

    .support{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.02);
      text-decoration:none;
      color: var(--text);
      font-weight: 780;
    }
    .support:hover{border-color: rgba(255,255,255,.18)}
    .support svg{
      width: 16px;
      height: 16px;
      opacity: .9;
      flex: 0 0 auto;
    }

    .freeze-wrap{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      flex: 1 1 auto;
      justify-content:flex-start;
      min-width: 220px;
    }
    .freeze-btn{
      background: rgba(255,255,255,.05);
    }
    .freeze-hint{
      font-size: 12px;
      color: rgba(255,255,255,.50);
      line-height: 1.35;
    }
    .frozen-badge{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.02);
      color: rgba(255,255,255,.80);
      font-weight: 780;
      letter-spacing: .2px;
      font-size: 12px;
      white-space: nowrap;
    }

    .site-footer{
      margin-top: 14px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      background: rgba(0,0,0,.18);
      padding: 14px 14px;
      display:flex;
      justify-content:space-between;
      gap: 12px;
      align-items:flex-start;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
    }
    .site-footer a{
      color: rgba(255,255,255,.82);
      text-decoration:none;
      border-bottom: 1px solid rgba(255,255,255,.20);
    }
    .site-footer a:hover{
      border-bottom-color: rgba(255,255,255,.40);
    }

    .toast{
      position: fixed;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.75);
      color: var(--text);
      box-shadow: var(--shadow);
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 30;
      max-width: min(760px, calc(100% - 24px));
      text-align:center;
      font-weight: 700;
    }
    .toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(-4px);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <button class="brand-btn" id="brandHome" aria-label="Hoodie or Nah home">
          <img src="/android-chrome-192x192.png" alt="Hoodie or Nah logo" />
        </button>

        <div class="wordmark">
          <div class="title">Hoodie or Nah</div>
          <div class="tag">Hoodie judgment, delivered.</div>
        </div>
      </div>

      <div class="header-right">
        <div class="units-seg" role="group" aria-label="Units">
          <button id="unitAuto" aria-pressed="true" title="Auto units (based on country)">Auto</button>
          <button id="unitF" aria-pressed="false" title="Force Fahrenheit">Â°F</button>
          <button id="unitC" aria-pressed="false" title="Force Celsius">Â°C</button>
        </div>

        <div class="pill" id="wherePill" title="Location" aria-live="polite">
          <span class="dot" aria-hidden="true"></span>
          <span id="whereText">Near you</span>
        </div>
      </div>
    </header>

    <main id="mainShell">
      <div class="grid">
        <section class="card" aria-live="polite" aria-atomic="true">
          <div class="big" id="bigWord">LOADING</div>
          <p class="sub" id="oneLiner">Grabbing your weather. Try not to panic.</p>

          <div class="divider"></div>

          <div class="stats">
            <div class="stat">
              <div class="k">Location</div>
              <div class="v" id="locLine">Near you</div>
              <div class="s" id="locSource">Source: guessing until you say otherwise.</div>
            </div>

            <div class="stat">
              <div class="k">Right now</div>
              <div class="v" id="tempLine">--</div>
              <div class="s" id="feelWindLine">Feels like: --  |  Wind: --</div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="in-card-footer">
            <a class="support" href="https://buymeacoffee.com/hoodieornah" target="_blank" rel="noopener">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M6.5 8.2h9.2c.8 0 1.4.6 1.4 1.4v3.7c0 2.7-2.2 4.9-4.9 4.9H10c-2.7 0-4.9-2.2-4.9-4.9V9.6c0-.8.6-1.4 1.4-1.4Z" stroke="rgba(255,255,255,.88)" stroke-width="1.7"/>
                <path d="M17.1 9.6h1.1c1.3 0 2.3 1 2.3 2.3s-1 2.3-2.3 2.3h-1.1" stroke="rgba(255,255,255,.78)" stroke-width="1.7" stroke-linecap="round"/>
                <path d="M7.6 21h9.2" stroke="rgba(255,255,255,.50)" stroke-width="1.7" stroke-linecap="round"/>
              </svg>
              <span>Support the hoodie science</span>
            </a>

            <div class="freeze-wrap" id="freezeWrap">
              <button class="freeze-btn" id="freezeBtn" type="button" aria-pressed="false">Freeze this take</button>
              <span class="freeze-hint" id="freezeHint">Locks this exact verdict so it never changes.</span>
              <span class="frozen-badge" id="frozenBadge" style="display:none;">Frozen mode</span>
            </div>

            <div id="unitsLine">Units: --</div>
          </div>
        </section>

        <aside class="card-right">
          <div>
            <h3>How do you run?</h3>
            <select id="runSelect" aria-label="How do you run">
              <option value="cold">Always cold</option>
              <option value="normal" selected>Normal</option>
              <option value="hot">Always hot</option>
            </select>

            <label for="manualInput">Manual location (optional)</label>
            <input id="manualInput" list="locList" placeholder="City, Region, Country or ZIP" autocomplete="off" />
            <datalist id="locList"></datalist>

            <div class="btn-row">
              <button id="spinBtn" type="button">Spin the globe</button>
              <button id="gpsBtn" type="button">Use my GPS</button>
            </div>
          </div>

          <div class="mini" aria-live="polite" id="summaryPanel">
            <div class="row"><span>Using</span><strong id="usingLine">Auto</strong></div>
            <div class="row"><span>Location</span><strong id="usingLoc">Near you</strong></div>
            <div class="row"><span>Units</span><strong id="usingUnits">--</strong></div>
            <div class="row"><span>Tip</span><strong id="tipLine">Type a city and press Enter.</strong></div>
          </div>
        </aside>
      </div>
    </main>

    <div class="site-footer">
      <div>
        <strong style="color:rgba(255,255,255,.86);">Contact</strong><br/>
        <a href="mailto:info@hoodieornah.com">info@hoodieornah.com</a><br/>
        <span style="color:rgba(255,255,255,.42);">We read it. Eventually.</span>
      </div>

      <div style="text-align:right; max-width: 64ch;">
        Weather data via Open-Meteo. Geocoding via OpenStreetMap Nominatim.<br/>
        This site is for entertainment and mild arguments only. No warranties. Do not sue us because you wore a hoodie in a blizzard.
      </div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    // ---------- State and persistence ----------
    const STORAGE_KEY = "hoodie_state_v2";
    const defaultState = {
      run: "normal",
      source: "auto",
      placeLabel: "Near you",
      lat: null,
      lon: null,
      countryCode: null,
      units: "F",         // effective units in use
      unitOverride: null, // null = auto, "F" or "C" = forced
      frozen: false,
      lastDecision: { word: "MAYBE", line: "" }
    };

    const state = loadState();

    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return Object.assign({}, defaultState);
        const parsed = JSON.parse(raw);
        return Object.assign({}, defaultState, parsed || {});
      }catch(e){
        return Object.assign({}, defaultState);
      }
    }

    function saveState(){
      try{
        const toSave = {
          run: state.run,
          source: state.source,
          placeLabel: state.placeLabel,
          lat: state.lat,
          lon: state.lon,
          countryCode: state.countryCode,
          units: state.units,
          unitOverride: state.unitOverride,
          frozen: state.frozen,
          lastDecision: state.lastDecision
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
      }catch(e){
        // ignore
      }
    }

    // ---------- Elements ----------
    const el = {
      wherePill: document.getElementById("wherePill"),
      bigWord: document.getElementById("bigWord"),
      oneLiner: document.getElementById("oneLiner"),
      toast: document.getElementById("toast"),

      runSelect: document.getElementById("runSelect"),
      manualInput: document.getElementById("manualInput"),
      locList: document.getElementById("locList"),
      spinBtn: document.getElementById("spinBtn"),
      gpsBtn: document.getElementById("gpsBtn"),
      brandHome: document.getElementById("brandHome"),

      freezeBtn: document.getElementById("freezeBtn"),
      freezeHint: document.getElementById("freezeHint"),
      frozenBadge: document.getElementById("frozenBadge"),

      locLine: document.getElementById("locLine"),
      locSource: document.getElementById("locSource"),
      tempLine: document.getElementById("tempLine"),
      feelWindLine: document.getElementById("feelWindLine"),
      unitsLine: document.getElementById("unitsLine"),

      usingLine: document.getElementById("usingLine"),
      usingLoc: document.getElementById("usingLoc"),
      usingUnits: document.getElementById("usingUnits"),
      tipLine: document.getElementById("tipLine"),

      unitAuto: document.getElementById("unitAuto"),
      unitF: document.getElementById("unitF"),
      unitC: document.getElementById("unitC")
    };

    // ---------- UI helpers ----------
    let loading = false;
    let suggestTimer = null;
    let suggestAbort = null;

    function showToast(msg){
      el.toast.textContent = msg;
      el.toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => el.toast.classList.remove("show"), 2500);
    }

    window.addEventListener("error", (e) => {
      console.error("JS error:", e.error || e.message);
      showToast("JS error. Open console. Something broke.");
      endLoading();
    });

    function setPillText(text){
      if (state.frozen) el.wherePill.classList.add("frozen");
      else el.wherePill.classList.remove("frozen");
      el.wherePill.innerHTML = '<span class="dot" aria-hidden="true"></span><span id="whereText"></span>';
      el.wherePill.querySelector("#whereText").textContent = text;
    }

    function setPillLoading(){
      el.wherePill.classList.remove("frozen");
      el.wherePill.innerHTML = '<span class="spinner" aria-hidden="true"></span><span id="whereText">Locating...</span>';
    }

    function countryUsesF(countryCode){
      return ["US", "LR", "MM"].includes((countryCode || "").toUpperCase());
    }

    function runOffset(run){
      if (run === "cold") return -4;
      if (run === "hot") return 4;
      return 0;
    }

    function fmtTemp(val, units){
      if (!Number.isFinite(val)) return "--";
      return Math.round(val) + "Â°" + units;
    }

    function fmtWind(val, units){
      if (!Number.isFinite(val)) return "--";
      return Math.round(val) + (units === "F" ? " mph" : " km/h");
    }

    function toF(c){ return (c * 9/5) + 32; }

    function setLoading(){
      loading = true;
      el.spinBtn.disabled = true;
      el.gpsBtn.disabled = true;
      el.manualInput.disabled = true;

      el.bigWord.classList.add("fade");
      setTimeout(() => el.bigWord.classList.remove("fade"), 20);

      el.bigWord.textContent = "LOADING";
      el.oneLiner.textContent = "Grabbing your weather. Try not to panic.";
      el.tempLine.textContent = "--";
      el.feelWindLine.textContent = "Feels like: --  |  Wind: --";
      el.unitsLine.textContent = "Units: --";
      el.usingUnits.textContent = "--";
    }

    function endLoading(){
      loading = false;
      el.spinBtn.disabled = !!state.frozen;
      el.gpsBtn.disabled = !!state.frozen;
      el.manualInput.disabled = !!state.frozen;
    }

    function updateSourceUI(){
      const sourceName =
        state.source === "gps" ? "GPS" :
        state.source === "manual" ? "Manual" :
        state.source === "globe" ? "Globe" : "Auto";

      el.usingLine.textContent = sourceName;
      el.usingLoc.textContent = state.placeLabel;
      el.usingUnits.textContent = (state.unitOverride ? (state.unitOverride === "F" ? "Fahrenheit (forced)" : "Celsius (forced)") : (state.units === "F" ? "Fahrenheit" : "Celsius"));
      el.tipLine.textContent = state.source === "manual" ? "Manual override wins. Always." : "Type a city and press Enter.";

      el.locLine.textContent = state.placeLabel;
      el.locSource.textContent = "Source: " + sourceName + ".";
      el.unitsLine.textContent = "Units: " + (state.unitOverride ? (state.unitOverride === "F" ? "Fahrenheit (forced)" : "Celsius (forced)") : (state.units === "F" ? "Fahrenheit" : "Celsius"));
    }

    // ---------- Snark and decision ----------
    const SNARK = {
      deepFreeze: [
        "That air hurts your face. Respectfully, no.",
        "If your breath is crunchy, it is coat season.",
        "Hoodie? Sure. Under the parka.",
        "The wind is auditioning to be your enemy.",
        "This is not hoodie weather. This is survival gear weather."
      ],
      veryCold: [
        "Hoodie alone is cute. So is hypothermia.",
        "Nah. Add a real jacket and stop pretending.",
        "This is the part where you learn about wind chill."
      ],
      cold: [
        "Hoodie plus a jacket. Do not get cocky.",
        "Layer up. Hoodie needs a bodyguard today.",
        "Hoodie is allowed, but bring backup."
      ],
      prime: [
        "Prime hoodie weather. Enjoy your moment.",
        "This is the whole point of hoodies existing.",
        "Hoodie time. No notes."
      ],
      mild: [
        "Hoodie if you like options. Otherwise, nah.",
        "This is borderline. Proceed with vibes.",
        "A thin hoodie works. A thick one is a mistake."
      ],
      warm: [
        "You are gonna regret sleeves in 10 minutes.",
        "Nah. Let your arms experience freedom.",
        "It is warm. Stop lying to yourself."
      ],
      hot: [
        "It is basically a warm hug from the sun. No hoodie.",
        "Nah. Hydrate and stop layering like a villain.",
        "This is not a hoodie day. This is a regret day."
      ]
    };

    function pick(arr){ return arr[Math.floor(Math.random() * arr.length)]; }

    function decide(tempF, feelsF, run){
      const t = (Number.isFinite(feelsF) ? feelsF : tempF) + runOffset(run);
      if (t <= 20) return { word: "NAH", line: pick(SNARK.deepFreeze) };
      if (t <= 35) return { word: "NAH", line: pick(SNARK.veryCold) };
      if (t <= 45) return { word: "MAYBE", line: pick(SNARK.cold) };
      if (t <= 60) return { word: "HOODIE", line: pick(SNARK.prime) };
      if (t <= 70) return { word: "MAYBE", line: pick(SNARK.mild) };
      if (t <= 82) return { word: "NAH", line: pick(SNARK.warm) };
      return { word: "NAH", line: pick(SNARK.hot) };
    }

    function escapeHtml(str){
      return String(str || "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    // ---------- Network helpers ----------
    async function fetchJson(url, timeoutMs = 12000){
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), timeoutMs);
      try{
        const res = await fetch(url, { signal: ctrl.signal, headers: { "Accept": "application/json" } });
        if (!res.ok) throw new Error("http_" + res.status);
        return await res.json();
      } finally {
        clearTimeout(t);
      }
    }

    async function fetchWeather(lat, lon, units){
      const tempUnit = units === "F" ? "fahrenheit" : "celsius";
      const windUnit = units === "F" ? "mph" : "kmh";

      const url =
        "https://api.open-meteo.com/v1/forecast" +
        "?latitude=" + encodeURIComponent(lat) +
        "&longitude=" + encodeURIComponent(lon) +
        "&current=temperature_2m,apparent_temperature,wind_speed_10m" +
        "&temperature_unit=" + tempUnit +
        "&windspeed_unit=" + windUnit +
        "&timezone=auto";

      return await fetchJson(url, 12000);
    }

    async function reverseGeocode(lat, lon){
      const url =
        "https://nominatim.openstreetmap.org/reverse" +
        "?format=jsonv2&addressdetails=1" +
        "&lat=" + encodeURIComponent(lat) +
        "&lon=" + encodeURIComponent(lon);

      const data = await fetchJson(url, 12000);
      const a = data.address || {};
      const city = a.city || a.town || a.village || a.hamlet || a.county || a.state || "";
      const stateName = a.state || a.region || "";
      const cc = a.country_code ? String(a.country_code).toUpperCase() : null;
      const country = a.country || "";

      let label = "";
      if (cc === "US"){
        const st = a.state_code || stateName;
        if (city && st) label = city + ", " + st;
        else if (data.display_name) label = data.display_name.split(",").slice(0,2).join(",").trim();
      } else if (city && country){
        label = city + ", " + country;
      } else if (data.display_name){
        label = data.display_name.split(",").slice(0,2).join(",").trim();
      }

      if (!label) label = data.display_name || "";

      return { label: label || null, countryCode: cc, raw: data || {} };
    }

    async function geocodeDisplayName(displayName){
      const url =
        "https://nominatim.openstreetmap.org/search" +
        "?format=jsonv2&addressdetails=1&limit=1&q=" + encodeURIComponent(displayName);

      const data = await fetchJson(url, 12000);
      if (!data || !data[0]) throw new Error("no_results");

      const item = data[0];
      const cc = item.address && item.address.country_code ? String(item.address.country_code).toUpperCase() : null;
      const a = item.address || {};
      const city = a.city || a.town || a.village || a.hamlet || a.county || a.state || "";
      const stateName = a.state || a.region || "";
      let label = item.display_name ? item.display_name.split(",").slice(0,2).join(",").trim() : displayName;
      if (cc === "US"){
        const st = a.state_code || stateName;
        if (city && st) label = city + ", " + st;
      } else if (city && a.country){
        label = city + ", " + a.country;
      }

      return {
        lat: parseFloat(item.lat),
        lon: parseFloat(item.lon),
        label,
        countryCode: cc
      };
    }

    // ---------- Render ----------
    function renderResult(temp, feels, wind){
      const tempF = (state.unitOverride === "C" ? toF(temp) : (state.units === "F" ? temp : toF(temp)));
      const feelsF = (state.unitOverride === "C" ? toF(feels) : (state.units === "F" ? feels : toF(feels)));
      // Choose decide based on Fahrenheit equivalent
      const d = decide(tempF, feelsF, state.run);
      state.lastDecision = { word: d.word, line: d.line };
      el.bigWord.textContent = d.word;
      el.oneLiner.textContent = d.line;

      // Display temperatures in the active displayed units:
      const displayUnits = state.unitOverride || state.units;
      const displayTemp = displayUnits === "F" ? (state.units === "F" ? temp : toF(temp)) : (state.units === "F" ? (temp - 32) * 5/9 : temp);
      const displayFeels = displayUnits === "F" ? (state.units === "F" ? feels : toF(feels)) : (state.units === "F" ? (feels - 32) * 5/9 : feels);

      el.tempLine.textContent = fmtTemp(displayTemp, displayUnits);
      el.feelWindLine.textContent = "Feels like: " + fmtTemp(displayFeels, displayUnits) + "  |  Wind: " + fmtWind(wind, displayUnits);

      updateSourceUI();
      saveState();
    }

    // ---------- Core updater (avoids double fetches) ----------
    async function updateWeatherFromLatLon(lat, lon, label, countryCode, source){
      if (state.frozen){
        showToast("This take is frozen. Unfreeze to update.");
        return;
      }

      // update basic state
      state.lat = lat;
      state.lon = lon;
      state.source = source || state.source;

      // Determine desired effective units:
      // If user forced unit -> use that. Else if reverse provided countryCode -> determine from it.
      const effectiveUnits = state.unitOverride ? state.unitOverride : (countryCode ? (countryUsesF(countryCode) ? "F" : "C") : state.units);
      const unitsChanged = effectiveUnits !== state.units;
      state.units = effectiveUnits;
      state.placeLabel = label || state.placeLabel || formatLatLonFallback(lat, lon);
      state.countryCode = countryCode || state.countryCode;

      setPillText("ðŸ“ " + state.placeLabel);
      updateSourceUI();

      setLoading();
      try{
        const data = await fetchWeather(lat, lon, state.units);
        const cur = data.current || {};
        renderResult(cur.temperature_2m, cur.apparent_temperature, cur.wind_speed_10m);
      }catch(e){
        console.error(e);
        el.bigWord.textContent = "MAYBE";
        el.oneLiner.textContent = "Weather fetch failed. The hoodie gods are silent.";
        showToast("Could not fetch weather. Try again.");
      }finally{
        endLoading();
        saveState();
      }
    }

    function formatLatLonFallback(lat, lon){
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return "Somewhere";
      return lat.toFixed(2) + "Â°, " + lon.toFixed(2) + "Â°";
    }

    // ---------- Auto location ----------
    async function tryAutoLocation(){
      state.source = "auto";
      state.placeLabel = "Near you";
      setPillText("Near you");
      updateSourceUI();

      setLoading();

      if (!navigator.geolocation){
        el.bigWord.textContent = "MAYBE";
        el.oneLiner.textContent = "No GPS here. Type a city and we will judge it anyway.";
        endLoading();
        return;
      }

      setPillLoading();

      const opts = { enableHighAccuracy: false, timeout: 8000, maximumAge: 120000 };

      navigator.geolocation.getCurrentPosition(async (pos) => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;

        // Fetch weather once
        await updateWeatherFromLatLon(lat, lon, "Near you", null, "gps");

        // Get nicer label & maybe units; only re-fetch if units would change (and not frozen)
        try{
          const rev = await reverseGeocode(lat, lon);
          if (rev && rev.label){
            const newUnits = state.unitOverride ? state.unitOverride : (rev.countryCode ? (countryUsesF(rev.countryCode) ? "F" : "C") : state.units);
            const unitsChanged = newUnits !== state.units;
            state.countryCode = rev.countryCode || state.countryCode;
            state.placeLabel = rev.label || state.placeLabel;
            state.units = newUnits;
            setPillText("ðŸ“ " + state.placeLabel);
            updateSourceUI();

            if (unitsChanged && !state.frozen){
              await updateWeatherFromLatLon(lat, lon, state.placeLabel, state.countryCode, "gps");
            }
          }
        }catch(err){
          console.warn("Reverse geocode failed:", err);
        }
      }, (err) => {
        console.warn("GPS failed:", err);
        setPillText("Near you");
        el.bigWord.textContent = "MAYBE";
        el.oneLiner.textContent = "No location, no problem. Type a place and let us argue about hoodies.";
        showToast(err && err.code === 1 ? "Location access denied" : "GPS error or timeout");
        endLoading();
      }, opts);
    }

    // ---------- Use GPS (explicit) ----------
    async function onUseGPS(){
      if (!navigator.geolocation){
        showToast("No GPS available in this browser.");
        return;
      }

      state.source = "gps";
      updateSourceUI();
      setPillLoading();
      setLoading();

      const opts = { enableHighAccuracy: true, timeout: 9000, maximumAge: 0 };

      navigator.geolocation.getCurrentPosition(async (pos) => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;

        // Fetch weather once (without country override)
        await updateWeatherFromLatLon(lat, lon, "Near you", null, "gps");

        // Label second; only re-fetch if units changed
        try{
          const rev = await reverseGeocode(lat, lon);
          if (rev && rev.label){
            const newUnits = state.unitOverride ? state.unitOverride : (rev.countryCode ? (countryUsesF(rev.countryCode) ? "F" : "C") : state.units);
            const unitsChanged = newUnits !== state.units;
            state.countryCode = rev.countryCode || state.countryCode;
            state.placeLabel = rev.label || state.placeLabel;
            state.units = newUnits;
            setPillText("ðŸ“ " + state.placeLabel);
            updateSourceUI();

            if (unitsChanged && !state.frozen){
              await updateWeatherFromLatLon(lat, lon, state.placeLabel, state.countryCode, "gps");
            }
          }
        }catch(err){
          console.warn("Reverse geocode failed:", err);
        }
      }, (err) => {
        console.warn("GPS failed:", err);
        setPillText("Near you");
        el.bigWord.textContent = "MAYBE";
        el.oneLiner.textContent = "Location failed. Type a city and we will still judge it.";
        showToast(err && err.code === 1 ? "Location access denied" : "GPS error or timeout");
        endLoading();
      }, opts);
    }

    // ---------- Spin the globe (option C: up to 3 re-rolls, land-biased) ----------
    async function onSpinGlobe(){
      if (state.frozen){
        showToast("This take is frozen. Unfreeze to spin the globe.");
        return;
      }

      state.source = "globe";
      updateSourceUI();
      setPillText("Spinning the globe...");
      setPillLoading();

      // Attempt up to 3 times to find a sensible land result
      const MAX_ATTEMPTS = 3;
      let attempt = 0;
      let chosen = null;
      let chosenRev = null;

      while (attempt < MAX_ATTEMPTS && !chosen){
        attempt++;
        // Slight bias away from poles by limiting lat range
        const lat = (Math.random() * 160) - 80; // -80 to +80
        const lon = (Math.random() * 360) - 180;

        // Show an immediate fallback label so UI isn't "Near you"
        const fallbackLabel = formatLatLonFallback(lat, lon);
        state.placeLabel = "Somewhere chaotic";
        setPillText("ðŸ“ " + state.placeLabel);
        updateSourceUI();

        // Fetch weather for that coordinate (first attempt)
        await updateWeatherFromLatLon(lat, lon, fallbackLabel, null, "globe");

        // Try reverse geocode
        try{
          // small polite delay between reverse-geocode attempts to avoid hammering
          await sleep(200 + Math.random() * 300); // 200-500ms jitter
          const rev = await reverseGeocode(lat, lon);
          const usefulLabel = rev && rev.label;
          const looksLikeOcean = looksLikeWater(rev && rev.raw);

          if (usefulLabel && !looksLikeOcean){
            // Good land result
            chosen = { lat, lon, rev };
            chosenRev = rev;
            break;
          } else if (usefulLabel && looksLikeOcean){
            // It's ocean; allow retry
            console.warn("Spin: landed on ocean-like location:", rev && rev.raw && rev.raw.display_name);
          } else {
            // No useful label; retry
          }

          // If last attempt and no good label, store last rev if it has countryCode or display_name
          if (attempt === MAX_ATTEMPTS && rev && (rev.label || rev.countryCode || (rev.raw && rev.raw.display_name))){
            chosen = { lat, lon, rev };
            chosenRev = rev;
            break;
          }
        }catch(err){
          console.warn("Spin reverse failed attempt", attempt, err);
          // continue and retry
          if (attempt === MAX_ATTEMPTS){
            // allow fallback to lat/lon
            chosen = { lat, lon, rev: null };
          }
        }
      }

      // If no chosen after attempts, fallback to last generated lat/lon (shouldn't happen)
      if (!chosen){
        const lat = (Math.random() * 160) - 80;
        const lon = (Math.random() * 360) - 180;
        chosen = { lat, lon, rev: null };
      }

      // finalize label and country code
      const finalLat = chosen.lat;
      const finalLon = chosen.lon;
      const rev = chosen.rev;
      let finalLabel = rev && rev.label ? rev.label : formatLatLonFallback(finalLat, finalLon);
      let finalCountry = rev && rev.countryCode ? rev.countryCode : null;

      // If reverse indicates water and has display_name with Ocean, make an explicit ocean label
      if (rev && looksLikeWater(rev.raw)){
        if (rev.raw && typeof rev.raw.display_name === "string" && /ocean|sea|bay|gulf/i.test(rev.raw.display_name)){
          finalLabel = (rev.raw.display_name.split(",").slice(0,2).join(", ").trim()) + " (ocean)";
        } else {
          finalLabel = formatLatLonFallback(finalLat, finalLon) + " (ocean?)";
        }
      }

      // Set place & maybe refetch with country-informed units
      state.placeLabel = finalLabel;
      state.countryCode = finalCountry || state.countryCode;
      setPillText("ðŸ“ " + state.placeLabel);
      updateSourceUI();

      // If reverse provided a country that changes units and user hasn't forced units, re-fetch
      const newUnits = state.unitOverride ? state.unitOverride : (finalCountry ? (countryUsesF(finalCountry) ? "F" : "C") : state.units);
      const unitsChanged = newUnits !== state.units;
      state.units = newUnits;
      saveState();

      if (unitsChanged && !state.frozen){
        await updateWeatherFromLatLon(finalLat, finalLon, state.placeLabel, state.countryCode, "globe");
      } else {
        // Ensure we at least have a weather result for the chosen coords (if not fetched yet)
        // updateWeatherFromLatLon was called at each attempt's first phase; ensure latest coords are shown
        await updateWeatherFromLatLon(finalLat, finalLon, state.placeLabel, state.countryCode, "globe");
      }
    }

    function looksLikeWater(raw){
      if (!raw) return false;
      // Nominatim reverse sometimes returns empty address for ocean, or display_name containing "Ocean" etc.
      const dn = String(raw.display_name || "").toLowerCase();
      if (!dn) return false;
      if (dn.includes("ocean") || dn.includes("sea") || dn.includes("gulf") || dn.includes("bay") || dn.includes("strait")) return true;
      // if address is empty or only contains water-related properties
      const addr = raw.address || {};
      if (Object.keys(addr).length === 0) return true;
      return false;
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    // ---------- Suggestions (debounced + abortable) ----------
    async function suggestLocations(q){
      const s = (q || "").trim();
      if (s.length < 3){
        el.locList.innerHTML = "";
        return;
      }

      if (suggestAbort) {
        try{ suggestAbort.abort(); } catch(e){}
      }
      if (suggestTimer) clearTimeout(suggestTimer);

      suggestTimer = setTimeout(async () => {
        suggestAbort = new AbortController();
        const url =
          "https://nominatim.openstreetmap.org/search" +
          "?format=jsonv2&addressdetails=1&limit=6&q=" + encodeURIComponent(s);

        try{
          const res = await fetch(url, { signal: suggestAbort.signal, headers: { "Accept": "application/json" } });
          if (!res.ok) return;
          const data = await res.json();

          el.locList.innerHTML = (data || []).map(item => {
            const label = item.display_name || "";
            return '<option value="' + escapeHtml(label) + '"></option>';
          }).join("");
        }catch(e){
          // ignore aborts and network hiccups
        } finally {
          suggestAbort = null;
        }
      }, 300); // 300ms debounce
    }

    // ---------- Manual submit ----------
    async function onManualSubmit(){
      const q = (el.manualInput.value || "").trim();
      if (!q){
        showToast("Type a place first.");
        return;
      }

      if (state.frozen){
        showToast("This take is frozen. Unfreeze to change location.");
        return;
      }

      state.source = "manual";
      updateSourceUI();
      setPillLoading();
      setLoading();

      try{
        const g = await geocodeDisplayName(q);
        await updateWeatherFromLatLon(g.lat, g.lon, g.label, g.countryCode, "manual");
      }catch(e){
        console.error(e);
        el.bigWord.textContent = "MAYBE";
        el.oneLiner.textContent = "Could not find that place. Try a nearby city or add a country.";
        showToast("No results for that location.");
        setPillText("Near you");
        endLoading();
      }
    }

    // ---------- Freeze / Unfreeze ----------
    function setFrozenUI(isFrozen){
      document.body.classList.toggle("is-frozen", isFrozen);
      el.freezeBtn.setAttribute("aria-pressed", String(!!isFrozen));
      el.freezeBtn.textContent = isFrozen ? "Unfreeze" : "Freeze this take";
      el.frozenBadge.style.display = isFrozen ? "inline-flex" : "none";
      el.spinBtn.disabled = isFrozen;
      el.gpsBtn.disabled = isFrozen;
      el.manualInput.disabled = isFrozen;
      el.unitAuto.disabled = isFrozen;
      el.unitF.disabled = isFrozen;
      el.unitC.disabled = isFrozen;
      if (isFrozen) el.wherePill.classList.add("frozen"); else el.wherePill.classList.remove("frozen");
    }

    function toggleFreeze(){
      state.frozen = !state.frozen;
      setFrozenUI(state.frozen);
      saveState();
      showToast(state.frozen ? "Take frozen. No more updates until you unfreeze." : "Unfrozen. Updates enabled.");
    }

    // ---------- Units segmented control ----------
    function setUnitControlButtons(){
      const auto = !state.unitOverride;
      el.unitAuto.setAttribute("aria-pressed", String(auto));
      el.unitF.setAttribute("aria-pressed", String(state.unitOverride === "F"));
      el.unitC.setAttribute("aria-pressed", String(state.unitOverride === "C"));
    }

    function applyUnitSelection(newSel){ // null, "F", "C"
      state.unitOverride = newSel;
      // If user forces, use that as effective units; otherwise determine from country code
      if (state.unitOverride){
        state.units = state.unitOverride;
      } else {
        state.units = state.countryCode ? (countryUsesF(state.countryCode) ? "F" : "C") : state.units;
      }
      setUnitControlButtons();
      saveState();
      // If there's a location, refresh weather with new units (unless frozen)
      if (!state.frozen && Number.isFinite(state.lat) && Number.isFinite(state.lon)){
        updateWeatherFromLatLon(state.lat, state.lon, state.placeLabel, state.countryCode, state.source);
      } else {
        updateSourceUI();
      }
    }

    // ---------- Init ----------
    function init(){
      // Wire up UI events
      el.runSelect.value = state.run || "normal";
      el.runSelect.addEventListener("change", () => {
        state.run = el.runSelect.value || "normal";
        saveState();
        if (Number.isFinite(state.lat) && Number.isFinite(state.lon) && !state.frozen){
          updateWeatherFromLatLon(state.lat, state.lon, state.placeLabel, state.countryCode, state.source);
        }
      });

      el.manualInput.addEventListener("input", () => {
        suggestLocations(el.manualInput.value);
      });

      el.manualInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter"){
          e.preventDefault();
          onManualSubmit();
        }
      });

      el.spinBtn.addEventListener("click", onSpinGlobe);
      el.gpsBtn.addEventListener("click", onUseGPS);

      el.brandHome.addEventListener("click", () => {
        el.manualInput.value = "";
        tryAutoLocation();
      });

      el.freezeBtn.addEventListener("click", toggleFreeze);

      el.unitAuto.addEventListener("click", () => applyUnitSelection(null));
      el.unitF.addEventListener("click", () => applyUnitSelection("F"));
      el.unitC.addEventListener("click", () => applyUnitSelection("C"));

      // Initialize UI from state
      setFrozenUI(state.frozen);
      setPillText(state.placeLabel || "Near you");
      setUnitControlButtons();
      updateSourceUI();

      // If we have saved lat/lon, try to restore last weather quickly (no reverse)
      if (Number.isFinite(state.lat) && Number.isFinite(state.lon)){
        // If frozen, just display lastDecision text if present
        if (state.frozen && state.lastDecision && state.lastDecision.word){
          el.bigWord.textContent = state.lastDecision.word;
          el.oneLiner.textContent = state.lastDecision.line || "";
          updateSourceUI();
        } else {
          // Fetch fresh weather for stored coords
          updateWeatherFromLatLon(state.lat, state.lon, state.placeLabel, state.countryCode, state.source);
        }
      } else {
        // No stored coords -> try auto location
        tryAutoLocation();
      }
    }

    init();
  </script>
</body>
</html>
